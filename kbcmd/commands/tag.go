package commands

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/killbill/kbcli/v3/kbcmd/kblib"

	"github.com/killbill/kbcli/v3/kbclient/tag_definition"

	"github.com/killbill/kbcli/v3/kbcmd/cmdlib"
	"github.com/killbill/kbcli/v3/kbcmd/cmdlib/args"
	"github.com/killbill/kbcli/v3/kbmodel"
	"github.com/urfave/cli"
)

var (
	createTagDefinitionProperties args.Properties
)

var tagDefinitionFormatter = cmdlib.Formatter{
	Columns: []cmdlib.Column{
		{
			Name: "NAME",
			Path: "$.name",
		},
		{
			Name: "ID",
			Path: "$.id",
		},
		{
			Name: "IS_CONTROL",
			Path: "$.isControlTag",
		},
		{
			Name: "DESCRIPTION",
			Path: "$.description",
		},
	},
}

func listTagDefinitions(ctx context.Context, o *cmdlib.Options) error {
	if len(o.Args) != 0 {
		return cmdlib.ErrorInvalidArgs
	}

	resp, err := o.Client().TagDefinition.GetTagDefinitions(ctx, &tag_definition.GetTagDefinitionsParams{})
	if err != nil {
		return err
	}
	o.Print(resp.Payload)
	return nil
}

func getTagDefinition(ctx context.Context, o *cmdlib.Options) error {
	if len(o.Args) != 1 {
		return cmdlib.ErrorInvalidArgs
	}
	idOrName := o.Args[0]
	td, err := kblib.GetTagDefinition(ctx, o.Client(), idOrName)
	if err != nil {
		return err
	}
	if td == nil {
		return fmt.Errorf("tag definition %s not found", idOrName)
	}
	o.Print(td)
	return nil
}

func createTagDefinition(ctx context.Context, o *cmdlib.Options) error {
	if len(o.Args) < 3 {
		return cmdlib.ErrorInvalidArgs
	}
	name := o.Args[0]
	description := o.Args[1]
	var applicableTypes []kbmodel.TagDefinitionApplicableObjectTypesEnum

	if o.Args[2] == "all" {
		for _, v := range kbmodel.TagDefinitionApplicableObjectTypesEnumValues {
			applicableTypes = append(applicableTypes, kbmodel.TagDefinitionApplicableObjectTypesEnum(v))
		}
	} else {
		list := strings.Split(o.Args[2], ",")
		for _, v := range list {
			e := kbmodel.TagDefinitionApplicableObjectTypesEnum(v)
			if !e.IsValid() {
				return fmt.Errorf("Invalid type: %s. Must be one of %s", v, strings.Join(kbmodel.TagObjectTypeEnumValues, ","))
			}
		}
	}

	tda := &kbmodel.TagDefinition{}
	err := args.LoadProperties(tda, createTagDefinitionProperties, o.Args[3:])
	if err != nil {
		return err
	}

	t := &kbmodel.TagDefinition{
		Name:                  &name,
		Description:           &description,
		ApplicableObjectTypes: applicableTypes,
		IsControlTag:          tda.IsControlTag,
	}
	resp, err := o.Client().TagDefinition.CreateTagDefinition(ctx, &tag_definition.CreateTagDefinitionParams{
		Body:                  t,
		ProcessLocationHeader: true,
	})
	if err != nil {
		return err
	}
	o.Print(resp.Payload)
	return nil
}

func deleteTagDefinitions(ctx context.Context, o *cmdlib.Options) error {
	if len(o.Args) != 1 {
		return cmdlib.ErrorInvalidArgs
	}
	idOrName := o.Args[0]
	td, err := kblib.GetTagDefinition(ctx, o.Client(), idOrName)
	if err != nil {
		return err
	}
	if td == nil {
		return fmt.Errorf("tag definition %s not found", idOrName)
	}

	_, err = o.Client().TagDefinition.DeleteTagDefinition(ctx, &tag_definition.DeleteTagDefinitionParams{
		TagDefinitionID: td.ID,
	})

	return err
}

func registerTagDefinitionCommands(r *cmdlib.App) {
	cmdlib.AddFormatter(reflect.TypeOf(&kbmodel.TagDefinition{}), tagDefinitionFormatter)
	createTagDefinitionProperties = args.GetProperties(&kbmodel.TagDefinition{})
	createTagDefinitionProperties.Get("IsControlTag").Default = "False"

	// Register top level command
	r.Register("", cli.Command{
		Name:  "tags",
		Usage: "tag related commands",
	}, nil)

	r.Register("tags", cli.Command{
		Name:  "list",
		Usage: "list tag definitions",
	}, listTagDefinitions)

	r.Register("tags", cli.Command{
		Name:      "get",
		Usage:     "get tag definition by name or id",
		ArgsUsage: "[NAME|ID]",
	}, getTagDefinition)

	r.Register("tags", cli.Command{
		Name:  "create",
		Usage: "create new tag definition",
		ArgsUsage: fmt.Sprintf(`NAME DESCRIPTION APPLICABLE_TYPES [IsControlTag=true/false]

   APPLICABLE_TYPES: comma separated values of tag targets. (use 'all' for all targets)
   Valid targets are:
   
   %s

   For e.g.,
     kbcmd tags create premium_account "Account has high transaction volume" ACCOUNT,INVOICE`,
			strings.Join(kbmodel.TagDefinitionApplicableObjectTypesEnumValues, "\n   ")),
	}, createTagDefinition)

	r.Register("tags", cli.Command{
		Name:  "delete",
		Usage: "delete tag definition",
		ArgsUsage: `[ID|NAME]
   For e.g.,
      kbcmd tags delete mytag
      (or)
      kbcmd tags delete d3cb5fcc-2004-47ee-ace3-ce7002c909af`,
	}, deleteTagDefinitions)
}
