// Code generated by go-swagger; DO NOT EDIT.

package kbmodel

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PaymentAttempt payment attempt
//
// swagger:model PaymentAttempt
type PaymentAttempt struct {

	// account Id
	// Format: uuid
	AccountID strfmt.UUID `json:"accountId,omitempty"`

	// Transaction amount, required except for void operations
	Amount float64 `json:"amount,omitempty"`

	// audit logs
	AuditLogs []*AuditLog `json:"auditLogs"`

	// Amount currency (account currency unless specified)
	// Enum: [AED AFN ALL AMD ANG AOA ARS AUD AWG AZN BAM BBD BDT BGN BHD BIF BMD BND BOB BRL BSD BTN BWP BYR BZD CAD CDF CHF CLP CNY COP CRC CUC CUP CVE CZK DJF DKK DOP DZD EGP ERN ETB EUR FJD FKP GBP GEL GGP GHS GIP GMD GNF GTQ GYD HKD HNL HRK HTG HUF IDR ILS IMP INR IQD IRR ISK JEP JMD JOD JPY KES KGS KHR KMF KPW KRW KWD KYD KZT LAK LBP LKR LRD LSL LTL LVL LYD MAD MDL MGA MKD MMK MNT MOP MRO MUR MVR MWK MXN MYR MZN NAD NGN NIO NOK NPR NZD OMR PAB PEN PGK PHP PKR PLN PYG QAR RON RSD RUB RWF SAR SBD SCR SDG SEK SGD SHP SLL SOS SPL SRD STD SVC SYP SZL THB TJS TMT TND TOP TRY TTD TVD TWD TZS UAH UGX USD UYU UZS VEF VND VUV WST XAF XCD XDR XOF XPF YER ZAR ZMW ZWD BTC]
	Currency string `json:"currency,omitempty"`

	// effective date
	// Format: date-time
	EffectiveDate strfmt.DateTime `json:"effectiveDate,omitempty"`

	// payment external key
	PaymentExternalKey string `json:"paymentExternalKey,omitempty"`

	// payment method Id
	// Format: uuid
	PaymentMethodID strfmt.UUID `json:"paymentMethodId,omitempty"`

	// plugin name
	PluginName string `json:"pluginName,omitempty"`

	// plugin properties
	PluginProperties []*PluginProperty `json:"pluginProperties"`

	// state name
	StateName string `json:"stateName,omitempty"`

	// transaction external key
	TransactionExternalKey string `json:"transactionExternalKey,omitempty"`

	// transaction Id
	// Format: uuid
	TransactionID strfmt.UUID `json:"transactionId,omitempty"`

	// transaction type
	// Enum: [AUTHORIZE CAPTURE CHARGEBACK CREDIT PURCHASE REFUND VOID]
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this payment attempt
func (m *PaymentAttempt) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuditLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentMethodID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePluginProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentAttempt) validateAccountID(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountID) { // not required
		return nil
	}

	if err := validate.FormatOf("accountId", "body", "uuid", m.AccountID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PaymentAttempt) validateAuditLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.AuditLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.AuditLogs); i++ {
		if swag.IsZero(m.AuditLogs[i]) { // not required
			continue
		}

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var paymentAttemptTypeCurrencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AED","AFN","ALL","AMD","ANG","AOA","ARS","AUD","AWG","AZN","BAM","BBD","BDT","BGN","BHD","BIF","BMD","BND","BOB","BRL","BSD","BTN","BWP","BYR","BZD","CAD","CDF","CHF","CLP","CNY","COP","CRC","CUC","CUP","CVE","CZK","DJF","DKK","DOP","DZD","EGP","ERN","ETB","EUR","FJD","FKP","GBP","GEL","GGP","GHS","GIP","GMD","GNF","GTQ","GYD","HKD","HNL","HRK","HTG","HUF","IDR","ILS","IMP","INR","IQD","IRR","ISK","JEP","JMD","JOD","JPY","KES","KGS","KHR","KMF","KPW","KRW","KWD","KYD","KZT","LAK","LBP","LKR","LRD","LSL","LTL","LVL","LYD","MAD","MDL","MGA","MKD","MMK","MNT","MOP","MRO","MUR","MVR","MWK","MXN","MYR","MZN","NAD","NGN","NIO","NOK","NPR","NZD","OMR","PAB","PEN","PGK","PHP","PKR","PLN","PYG","QAR","RON","RSD","RUB","RWF","SAR","SBD","SCR","SDG","SEK","SGD","SHP","SLL","SOS","SPL","SRD","STD","SVC","SYP","SZL","THB","TJS","TMT","TND","TOP","TRY","TTD","TVD","TWD","TZS","UAH","UGX","USD","UYU","UZS","VEF","VND","VUV","WST","XAF","XCD","XDR","XOF","XPF","YER","ZAR","ZMW","ZWD","BTC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentAttemptTypeCurrencyPropEnum = append(paymentAttemptTypeCurrencyPropEnum, v)
	}
}

const (

	// PaymentAttemptCurrencyAED captures enum value "AED"
	PaymentAttemptCurrencyAED string = "AED"

	// PaymentAttemptCurrencyAFN captures enum value "AFN"
	PaymentAttemptCurrencyAFN string = "AFN"

	// PaymentAttemptCurrencyALL captures enum value "ALL"
	PaymentAttemptCurrencyALL string = "ALL"

	// PaymentAttemptCurrencyAMD captures enum value "AMD"
	PaymentAttemptCurrencyAMD string = "AMD"

	// PaymentAttemptCurrencyANG captures enum value "ANG"
	PaymentAttemptCurrencyANG string = "ANG"

	// PaymentAttemptCurrencyAOA captures enum value "AOA"
	PaymentAttemptCurrencyAOA string = "AOA"

	// PaymentAttemptCurrencyARS captures enum value "ARS"
	PaymentAttemptCurrencyARS string = "ARS"

	// PaymentAttemptCurrencyAUD captures enum value "AUD"
	PaymentAttemptCurrencyAUD string = "AUD"

	// PaymentAttemptCurrencyAWG captures enum value "AWG"
	PaymentAttemptCurrencyAWG string = "AWG"

	// PaymentAttemptCurrencyAZN captures enum value "AZN"
	PaymentAttemptCurrencyAZN string = "AZN"

	// PaymentAttemptCurrencyBAM captures enum value "BAM"
	PaymentAttemptCurrencyBAM string = "BAM"

	// PaymentAttemptCurrencyBBD captures enum value "BBD"
	PaymentAttemptCurrencyBBD string = "BBD"

	// PaymentAttemptCurrencyBDT captures enum value "BDT"
	PaymentAttemptCurrencyBDT string = "BDT"

	// PaymentAttemptCurrencyBGN captures enum value "BGN"
	PaymentAttemptCurrencyBGN string = "BGN"

	// PaymentAttemptCurrencyBHD captures enum value "BHD"
	PaymentAttemptCurrencyBHD string = "BHD"

	// PaymentAttemptCurrencyBIF captures enum value "BIF"
	PaymentAttemptCurrencyBIF string = "BIF"

	// PaymentAttemptCurrencyBMD captures enum value "BMD"
	PaymentAttemptCurrencyBMD string = "BMD"

	// PaymentAttemptCurrencyBND captures enum value "BND"
	PaymentAttemptCurrencyBND string = "BND"

	// PaymentAttemptCurrencyBOB captures enum value "BOB"
	PaymentAttemptCurrencyBOB string = "BOB"

	// PaymentAttemptCurrencyBRL captures enum value "BRL"
	PaymentAttemptCurrencyBRL string = "BRL"

	// PaymentAttemptCurrencyBSD captures enum value "BSD"
	PaymentAttemptCurrencyBSD string = "BSD"

	// PaymentAttemptCurrencyBTN captures enum value "BTN"
	PaymentAttemptCurrencyBTN string = "BTN"

	// PaymentAttemptCurrencyBWP captures enum value "BWP"
	PaymentAttemptCurrencyBWP string = "BWP"

	// PaymentAttemptCurrencyBYR captures enum value "BYR"
	PaymentAttemptCurrencyBYR string = "BYR"

	// PaymentAttemptCurrencyBZD captures enum value "BZD"
	PaymentAttemptCurrencyBZD string = "BZD"

	// PaymentAttemptCurrencyCAD captures enum value "CAD"
	PaymentAttemptCurrencyCAD string = "CAD"

	// PaymentAttemptCurrencyCDF captures enum value "CDF"
	PaymentAttemptCurrencyCDF string = "CDF"

	// PaymentAttemptCurrencyCHF captures enum value "CHF"
	PaymentAttemptCurrencyCHF string = "CHF"

	// PaymentAttemptCurrencyCLP captures enum value "CLP"
	PaymentAttemptCurrencyCLP string = "CLP"

	// PaymentAttemptCurrencyCNY captures enum value "CNY"
	PaymentAttemptCurrencyCNY string = "CNY"

	// PaymentAttemptCurrencyCOP captures enum value "COP"
	PaymentAttemptCurrencyCOP string = "COP"

	// PaymentAttemptCurrencyCRC captures enum value "CRC"
	PaymentAttemptCurrencyCRC string = "CRC"

	// PaymentAttemptCurrencyCUC captures enum value "CUC"
	PaymentAttemptCurrencyCUC string = "CUC"

	// PaymentAttemptCurrencyCUP captures enum value "CUP"
	PaymentAttemptCurrencyCUP string = "CUP"

	// PaymentAttemptCurrencyCVE captures enum value "CVE"
	PaymentAttemptCurrencyCVE string = "CVE"

	// PaymentAttemptCurrencyCZK captures enum value "CZK"
	PaymentAttemptCurrencyCZK string = "CZK"

	// PaymentAttemptCurrencyDJF captures enum value "DJF"
	PaymentAttemptCurrencyDJF string = "DJF"

	// PaymentAttemptCurrencyDKK captures enum value "DKK"
	PaymentAttemptCurrencyDKK string = "DKK"

	// PaymentAttemptCurrencyDOP captures enum value "DOP"
	PaymentAttemptCurrencyDOP string = "DOP"

	// PaymentAttemptCurrencyDZD captures enum value "DZD"
	PaymentAttemptCurrencyDZD string = "DZD"

	// PaymentAttemptCurrencyEGP captures enum value "EGP"
	PaymentAttemptCurrencyEGP string = "EGP"

	// PaymentAttemptCurrencyERN captures enum value "ERN"
	PaymentAttemptCurrencyERN string = "ERN"

	// PaymentAttemptCurrencyETB captures enum value "ETB"
	PaymentAttemptCurrencyETB string = "ETB"

	// PaymentAttemptCurrencyEUR captures enum value "EUR"
	PaymentAttemptCurrencyEUR string = "EUR"

	// PaymentAttemptCurrencyFJD captures enum value "FJD"
	PaymentAttemptCurrencyFJD string = "FJD"

	// PaymentAttemptCurrencyFKP captures enum value "FKP"
	PaymentAttemptCurrencyFKP string = "FKP"

	// PaymentAttemptCurrencyGBP captures enum value "GBP"
	PaymentAttemptCurrencyGBP string = "GBP"

	// PaymentAttemptCurrencyGEL captures enum value "GEL"
	PaymentAttemptCurrencyGEL string = "GEL"

	// PaymentAttemptCurrencyGGP captures enum value "GGP"
	PaymentAttemptCurrencyGGP string = "GGP"

	// PaymentAttemptCurrencyGHS captures enum value "GHS"
	PaymentAttemptCurrencyGHS string = "GHS"

	// PaymentAttemptCurrencyGIP captures enum value "GIP"
	PaymentAttemptCurrencyGIP string = "GIP"

	// PaymentAttemptCurrencyGMD captures enum value "GMD"
	PaymentAttemptCurrencyGMD string = "GMD"

	// PaymentAttemptCurrencyGNF captures enum value "GNF"
	PaymentAttemptCurrencyGNF string = "GNF"

	// PaymentAttemptCurrencyGTQ captures enum value "GTQ"
	PaymentAttemptCurrencyGTQ string = "GTQ"

	// PaymentAttemptCurrencyGYD captures enum value "GYD"
	PaymentAttemptCurrencyGYD string = "GYD"

	// PaymentAttemptCurrencyHKD captures enum value "HKD"
	PaymentAttemptCurrencyHKD string = "HKD"

	// PaymentAttemptCurrencyHNL captures enum value "HNL"
	PaymentAttemptCurrencyHNL string = "HNL"

	// PaymentAttemptCurrencyHRK captures enum value "HRK"
	PaymentAttemptCurrencyHRK string = "HRK"

	// PaymentAttemptCurrencyHTG captures enum value "HTG"
	PaymentAttemptCurrencyHTG string = "HTG"

	// PaymentAttemptCurrencyHUF captures enum value "HUF"
	PaymentAttemptCurrencyHUF string = "HUF"

	// PaymentAttemptCurrencyIDR captures enum value "IDR"
	PaymentAttemptCurrencyIDR string = "IDR"

	// PaymentAttemptCurrencyILS captures enum value "ILS"
	PaymentAttemptCurrencyILS string = "ILS"

	// PaymentAttemptCurrencyIMP captures enum value "IMP"
	PaymentAttemptCurrencyIMP string = "IMP"

	// PaymentAttemptCurrencyINR captures enum value "INR"
	PaymentAttemptCurrencyINR string = "INR"

	// PaymentAttemptCurrencyIQD captures enum value "IQD"
	PaymentAttemptCurrencyIQD string = "IQD"

	// PaymentAttemptCurrencyIRR captures enum value "IRR"
	PaymentAttemptCurrencyIRR string = "IRR"

	// PaymentAttemptCurrencyISK captures enum value "ISK"
	PaymentAttemptCurrencyISK string = "ISK"

	// PaymentAttemptCurrencyJEP captures enum value "JEP"
	PaymentAttemptCurrencyJEP string = "JEP"

	// PaymentAttemptCurrencyJMD captures enum value "JMD"
	PaymentAttemptCurrencyJMD string = "JMD"

	// PaymentAttemptCurrencyJOD captures enum value "JOD"
	PaymentAttemptCurrencyJOD string = "JOD"

	// PaymentAttemptCurrencyJPY captures enum value "JPY"
	PaymentAttemptCurrencyJPY string = "JPY"

	// PaymentAttemptCurrencyKES captures enum value "KES"
	PaymentAttemptCurrencyKES string = "KES"

	// PaymentAttemptCurrencyKGS captures enum value "KGS"
	PaymentAttemptCurrencyKGS string = "KGS"

	// PaymentAttemptCurrencyKHR captures enum value "KHR"
	PaymentAttemptCurrencyKHR string = "KHR"

	// PaymentAttemptCurrencyKMF captures enum value "KMF"
	PaymentAttemptCurrencyKMF string = "KMF"

	// PaymentAttemptCurrencyKPW captures enum value "KPW"
	PaymentAttemptCurrencyKPW string = "KPW"

	// PaymentAttemptCurrencyKRW captures enum value "KRW"
	PaymentAttemptCurrencyKRW string = "KRW"

	// PaymentAttemptCurrencyKWD captures enum value "KWD"
	PaymentAttemptCurrencyKWD string = "KWD"

	// PaymentAttemptCurrencyKYD captures enum value "KYD"
	PaymentAttemptCurrencyKYD string = "KYD"

	// PaymentAttemptCurrencyKZT captures enum value "KZT"
	PaymentAttemptCurrencyKZT string = "KZT"

	// PaymentAttemptCurrencyLAK captures enum value "LAK"
	PaymentAttemptCurrencyLAK string = "LAK"

	// PaymentAttemptCurrencyLBP captures enum value "LBP"
	PaymentAttemptCurrencyLBP string = "LBP"

	// PaymentAttemptCurrencyLKR captures enum value "LKR"
	PaymentAttemptCurrencyLKR string = "LKR"

	// PaymentAttemptCurrencyLRD captures enum value "LRD"
	PaymentAttemptCurrencyLRD string = "LRD"

	// PaymentAttemptCurrencyLSL captures enum value "LSL"
	PaymentAttemptCurrencyLSL string = "LSL"

	// PaymentAttemptCurrencyLTL captures enum value "LTL"
	PaymentAttemptCurrencyLTL string = "LTL"

	// PaymentAttemptCurrencyLVL captures enum value "LVL"
	PaymentAttemptCurrencyLVL string = "LVL"

	// PaymentAttemptCurrencyLYD captures enum value "LYD"
	PaymentAttemptCurrencyLYD string = "LYD"

	// PaymentAttemptCurrencyMAD captures enum value "MAD"
	PaymentAttemptCurrencyMAD string = "MAD"

	// PaymentAttemptCurrencyMDL captures enum value "MDL"
	PaymentAttemptCurrencyMDL string = "MDL"

	// PaymentAttemptCurrencyMGA captures enum value "MGA"
	PaymentAttemptCurrencyMGA string = "MGA"

	// PaymentAttemptCurrencyMKD captures enum value "MKD"
	PaymentAttemptCurrencyMKD string = "MKD"

	// PaymentAttemptCurrencyMMK captures enum value "MMK"
	PaymentAttemptCurrencyMMK string = "MMK"

	// PaymentAttemptCurrencyMNT captures enum value "MNT"
	PaymentAttemptCurrencyMNT string = "MNT"

	// PaymentAttemptCurrencyMOP captures enum value "MOP"
	PaymentAttemptCurrencyMOP string = "MOP"

	// PaymentAttemptCurrencyMRO captures enum value "MRO"
	PaymentAttemptCurrencyMRO string = "MRO"

	// PaymentAttemptCurrencyMUR captures enum value "MUR"
	PaymentAttemptCurrencyMUR string = "MUR"

	// PaymentAttemptCurrencyMVR captures enum value "MVR"
	PaymentAttemptCurrencyMVR string = "MVR"

	// PaymentAttemptCurrencyMWK captures enum value "MWK"
	PaymentAttemptCurrencyMWK string = "MWK"

	// PaymentAttemptCurrencyMXN captures enum value "MXN"
	PaymentAttemptCurrencyMXN string = "MXN"

	// PaymentAttemptCurrencyMYR captures enum value "MYR"
	PaymentAttemptCurrencyMYR string = "MYR"

	// PaymentAttemptCurrencyMZN captures enum value "MZN"
	PaymentAttemptCurrencyMZN string = "MZN"

	// PaymentAttemptCurrencyNAD captures enum value "NAD"
	PaymentAttemptCurrencyNAD string = "NAD"

	// PaymentAttemptCurrencyNGN captures enum value "NGN"
	PaymentAttemptCurrencyNGN string = "NGN"

	// PaymentAttemptCurrencyNIO captures enum value "NIO"
	PaymentAttemptCurrencyNIO string = "NIO"

	// PaymentAttemptCurrencyNOK captures enum value "NOK"
	PaymentAttemptCurrencyNOK string = "NOK"

	// PaymentAttemptCurrencyNPR captures enum value "NPR"
	PaymentAttemptCurrencyNPR string = "NPR"

	// PaymentAttemptCurrencyNZD captures enum value "NZD"
	PaymentAttemptCurrencyNZD string = "NZD"

	// PaymentAttemptCurrencyOMR captures enum value "OMR"
	PaymentAttemptCurrencyOMR string = "OMR"

	// PaymentAttemptCurrencyPAB captures enum value "PAB"
	PaymentAttemptCurrencyPAB string = "PAB"

	// PaymentAttemptCurrencyPEN captures enum value "PEN"
	PaymentAttemptCurrencyPEN string = "PEN"

	// PaymentAttemptCurrencyPGK captures enum value "PGK"
	PaymentAttemptCurrencyPGK string = "PGK"

	// PaymentAttemptCurrencyPHP captures enum value "PHP"
	PaymentAttemptCurrencyPHP string = "PHP"

	// PaymentAttemptCurrencyPKR captures enum value "PKR"
	PaymentAttemptCurrencyPKR string = "PKR"

	// PaymentAttemptCurrencyPLN captures enum value "PLN"
	PaymentAttemptCurrencyPLN string = "PLN"

	// PaymentAttemptCurrencyPYG captures enum value "PYG"
	PaymentAttemptCurrencyPYG string = "PYG"

	// PaymentAttemptCurrencyQAR captures enum value "QAR"
	PaymentAttemptCurrencyQAR string = "QAR"

	// PaymentAttemptCurrencyRON captures enum value "RON"
	PaymentAttemptCurrencyRON string = "RON"

	// PaymentAttemptCurrencyRSD captures enum value "RSD"
	PaymentAttemptCurrencyRSD string = "RSD"

	// PaymentAttemptCurrencyRUB captures enum value "RUB"
	PaymentAttemptCurrencyRUB string = "RUB"

	// PaymentAttemptCurrencyRWF captures enum value "RWF"
	PaymentAttemptCurrencyRWF string = "RWF"

	// PaymentAttemptCurrencySAR captures enum value "SAR"
	PaymentAttemptCurrencySAR string = "SAR"

	// PaymentAttemptCurrencySBD captures enum value "SBD"
	PaymentAttemptCurrencySBD string = "SBD"

	// PaymentAttemptCurrencySCR captures enum value "SCR"
	PaymentAttemptCurrencySCR string = "SCR"

	// PaymentAttemptCurrencySDG captures enum value "SDG"
	PaymentAttemptCurrencySDG string = "SDG"

	// PaymentAttemptCurrencySEK captures enum value "SEK"
	PaymentAttemptCurrencySEK string = "SEK"

	// PaymentAttemptCurrencySGD captures enum value "SGD"
	PaymentAttemptCurrencySGD string = "SGD"

	// PaymentAttemptCurrencySHP captures enum value "SHP"
	PaymentAttemptCurrencySHP string = "SHP"

	// PaymentAttemptCurrencySLL captures enum value "SLL"
	PaymentAttemptCurrencySLL string = "SLL"

	// PaymentAttemptCurrencySOS captures enum value "SOS"
	PaymentAttemptCurrencySOS string = "SOS"

	// PaymentAttemptCurrencySPL captures enum value "SPL"
	PaymentAttemptCurrencySPL string = "SPL"

	// PaymentAttemptCurrencySRD captures enum value "SRD"
	PaymentAttemptCurrencySRD string = "SRD"

	// PaymentAttemptCurrencySTD captures enum value "STD"
	PaymentAttemptCurrencySTD string = "STD"

	// PaymentAttemptCurrencySVC captures enum value "SVC"
	PaymentAttemptCurrencySVC string = "SVC"

	// PaymentAttemptCurrencySYP captures enum value "SYP"
	PaymentAttemptCurrencySYP string = "SYP"

	// PaymentAttemptCurrencySZL captures enum value "SZL"
	PaymentAttemptCurrencySZL string = "SZL"

	// PaymentAttemptCurrencyTHB captures enum value "THB"
	PaymentAttemptCurrencyTHB string = "THB"

	// PaymentAttemptCurrencyTJS captures enum value "TJS"
	PaymentAttemptCurrencyTJS string = "TJS"

	// PaymentAttemptCurrencyTMT captures enum value "TMT"
	PaymentAttemptCurrencyTMT string = "TMT"

	// PaymentAttemptCurrencyTND captures enum value "TND"
	PaymentAttemptCurrencyTND string = "TND"

	// PaymentAttemptCurrencyTOP captures enum value "TOP"
	PaymentAttemptCurrencyTOP string = "TOP"

	// PaymentAttemptCurrencyTRY captures enum value "TRY"
	PaymentAttemptCurrencyTRY string = "TRY"

	// PaymentAttemptCurrencyTTD captures enum value "TTD"
	PaymentAttemptCurrencyTTD string = "TTD"

	// PaymentAttemptCurrencyTVD captures enum value "TVD"
	PaymentAttemptCurrencyTVD string = "TVD"

	// PaymentAttemptCurrencyTWD captures enum value "TWD"
	PaymentAttemptCurrencyTWD string = "TWD"

	// PaymentAttemptCurrencyTZS captures enum value "TZS"
	PaymentAttemptCurrencyTZS string = "TZS"

	// PaymentAttemptCurrencyUAH captures enum value "UAH"
	PaymentAttemptCurrencyUAH string = "UAH"

	// PaymentAttemptCurrencyUGX captures enum value "UGX"
	PaymentAttemptCurrencyUGX string = "UGX"

	// PaymentAttemptCurrencyUSD captures enum value "USD"
	PaymentAttemptCurrencyUSD string = "USD"

	// PaymentAttemptCurrencyUYU captures enum value "UYU"
	PaymentAttemptCurrencyUYU string = "UYU"

	// PaymentAttemptCurrencyUZS captures enum value "UZS"
	PaymentAttemptCurrencyUZS string = "UZS"

	// PaymentAttemptCurrencyVEF captures enum value "VEF"
	PaymentAttemptCurrencyVEF string = "VEF"

	// PaymentAttemptCurrencyVND captures enum value "VND"
	PaymentAttemptCurrencyVND string = "VND"

	// PaymentAttemptCurrencyVUV captures enum value "VUV"
	PaymentAttemptCurrencyVUV string = "VUV"

	// PaymentAttemptCurrencyWST captures enum value "WST"
	PaymentAttemptCurrencyWST string = "WST"

	// PaymentAttemptCurrencyXAF captures enum value "XAF"
	PaymentAttemptCurrencyXAF string = "XAF"

	// PaymentAttemptCurrencyXCD captures enum value "XCD"
	PaymentAttemptCurrencyXCD string = "XCD"

	// PaymentAttemptCurrencyXDR captures enum value "XDR"
	PaymentAttemptCurrencyXDR string = "XDR"

	// PaymentAttemptCurrencyXOF captures enum value "XOF"
	PaymentAttemptCurrencyXOF string = "XOF"

	// PaymentAttemptCurrencyXPF captures enum value "XPF"
	PaymentAttemptCurrencyXPF string = "XPF"

	// PaymentAttemptCurrencyYER captures enum value "YER"
	PaymentAttemptCurrencyYER string = "YER"

	// PaymentAttemptCurrencyZAR captures enum value "ZAR"
	PaymentAttemptCurrencyZAR string = "ZAR"

	// PaymentAttemptCurrencyZMW captures enum value "ZMW"
	PaymentAttemptCurrencyZMW string = "ZMW"

	// PaymentAttemptCurrencyZWD captures enum value "ZWD"
	PaymentAttemptCurrencyZWD string = "ZWD"

	// PaymentAttemptCurrencyBTC captures enum value "BTC"
	PaymentAttemptCurrencyBTC string = "BTC"
)

// prop value enum
func (m *PaymentAttempt) validateCurrencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentAttemptTypeCurrencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PaymentAttempt) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	// value enum
	if err := m.validateCurrencyEnum("currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *PaymentAttempt) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("effectiveDate", "body", "date-time", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PaymentAttempt) validatePaymentMethodID(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentMethodID) { // not required
		return nil
	}

	if err := validate.FormatOf("paymentMethodId", "body", "uuid", m.PaymentMethodID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PaymentAttempt) validatePluginProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.PluginProperties) { // not required
		return nil
	}

	for i := 0; i < len(m.PluginProperties); i++ {
		if swag.IsZero(m.PluginProperties[i]) { // not required
			continue
		}

		if m.PluginProperties[i] != nil {
			if err := m.PluginProperties[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pluginProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pluginProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PaymentAttempt) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(m.TransactionID) { // not required
		return nil
	}

	if err := validate.FormatOf("transactionId", "body", "uuid", m.TransactionID.String(), formats); err != nil {
		return err
	}

	return nil
}

var paymentAttemptTypeTransactionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AUTHORIZE","CAPTURE","CHARGEBACK","CREDIT","PURCHASE","REFUND","VOID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentAttemptTypeTransactionTypePropEnum = append(paymentAttemptTypeTransactionTypePropEnum, v)
	}
}

const (

	// PaymentAttemptTransactionTypeAUTHORIZE captures enum value "AUTHORIZE"
	PaymentAttemptTransactionTypeAUTHORIZE string = "AUTHORIZE"

	// PaymentAttemptTransactionTypeCAPTURE captures enum value "CAPTURE"
	PaymentAttemptTransactionTypeCAPTURE string = "CAPTURE"

	// PaymentAttemptTransactionTypeCHARGEBACK captures enum value "CHARGEBACK"
	PaymentAttemptTransactionTypeCHARGEBACK string = "CHARGEBACK"

	// PaymentAttemptTransactionTypeCREDIT captures enum value "CREDIT"
	PaymentAttemptTransactionTypeCREDIT string = "CREDIT"

	// PaymentAttemptTransactionTypePURCHASE captures enum value "PURCHASE"
	PaymentAttemptTransactionTypePURCHASE string = "PURCHASE"

	// PaymentAttemptTransactionTypeREFUND captures enum value "REFUND"
	PaymentAttemptTransactionTypeREFUND string = "REFUND"

	// PaymentAttemptTransactionTypeVOID captures enum value "VOID"
	PaymentAttemptTransactionTypeVOID string = "VOID"
)

// prop value enum
func (m *PaymentAttempt) validateTransactionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentAttemptTypeTransactionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PaymentAttempt) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(m.TransactionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTransactionTypeEnum("transactionType", "body", m.TransactionType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payment attempt based on the context it is used
func (m *PaymentAttempt) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuditLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePluginProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentAttempt) contextValidateAuditLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuditLogs); i++ {

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PaymentAttempt) contextValidatePluginProperties(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PluginProperties); i++ {

		if m.PluginProperties[i] != nil {
			if err := m.PluginProperties[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pluginProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pluginProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentAttempt) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentAttempt) UnmarshalBinary(b []byte) error {
	var res PaymentAttempt
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
