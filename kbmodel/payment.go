// Code generated by go-swagger; DO NOT EDIT.

package kbmodel

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment payment
//
// swagger:model Payment
type Payment struct {

	// account Id
	// Format: uuid
	AccountID strfmt.UUID `json:"accountId,omitempty"`

	// audit logs
	AuditLogs []*AuditLog `json:"auditLogs"`

	// auth amount
	AuthAmount float64 `json:"authAmount,omitempty"`

	// captured amount
	CapturedAmount float64 `json:"capturedAmount,omitempty"`

	// credited amount
	CreditedAmount float64 `json:"creditedAmount,omitempty"`

	// currency
	// Enum: [AED AFN ALL AMD ANG AOA ARS AUD AWG AZN BAM BBD BDT BGN BHD BIF BMD BND BOB BRL BSD BTN BWP BYR BZD CAD CDF CHF CLP CNY COP CRC CUC CUP CVE CZK DJF DKK DOP DZD EGP ERN ETB EUR FJD FKP GBP GEL GGP GHS GIP GMD GNF GTQ GYD HKD HNL HRK HTG HUF IDR ILS IMP INR IQD IRR ISK JEP JMD JOD JPY KES KGS KHR KMF KPW KRW KWD KYD KZT LAK LBP LKR LRD LSL LTL LVL LYD MAD MDL MGA MKD MMK MNT MOP MRO MUR MVR MWK MXN MYR MZN NAD NGN NIO NOK NPR NZD OMR PAB PEN PGK PHP PKR PLN PYG QAR RON RSD RUB RWF SAR SBD SCR SDG SEK SGD SHP SLL SOS SPL SRD STD SVC SYP SZL THB TJS TMT TND TOP TRY TTD TVD TWD TZS UAH UGX USD UYU UZS VEF VND VUV WST XAF XCD XDR XOF XPF YER ZAR ZMW ZWD BTC]
	Currency string `json:"currency,omitempty"`

	// payment attempts
	PaymentAttempts []*PaymentAttempt `json:"paymentAttempts"`

	// payment external key
	PaymentExternalKey string `json:"paymentExternalKey,omitempty"`

	// payment Id
	// Format: uuid
	PaymentID strfmt.UUID `json:"paymentId,omitempty"`

	// payment method Id
	// Format: uuid
	PaymentMethodID strfmt.UUID `json:"paymentMethodId,omitempty"`

	// payment number
	PaymentNumber string `json:"paymentNumber,omitempty"`

	// purchased amount
	PurchasedAmount float64 `json:"purchasedAmount,omitempty"`

	// refunded amount
	RefundedAmount float64 `json:"refundedAmount,omitempty"`

	// transactions
	Transactions []*PaymentTransaction `json:"transactions"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuditLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentAttempts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentMethodID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateAccountID(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountID) { // not required
		return nil
	}

	if err := validate.FormatOf("accountId", "body", "uuid", m.AccountID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateAuditLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.AuditLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.AuditLogs); i++ {
		if swag.IsZero(m.AuditLogs[i]) { // not required
			continue
		}

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var paymentTypeCurrencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AED","AFN","ALL","AMD","ANG","AOA","ARS","AUD","AWG","AZN","BAM","BBD","BDT","BGN","BHD","BIF","BMD","BND","BOB","BRL","BSD","BTN","BWP","BYR","BZD","CAD","CDF","CHF","CLP","CNY","COP","CRC","CUC","CUP","CVE","CZK","DJF","DKK","DOP","DZD","EGP","ERN","ETB","EUR","FJD","FKP","GBP","GEL","GGP","GHS","GIP","GMD","GNF","GTQ","GYD","HKD","HNL","HRK","HTG","HUF","IDR","ILS","IMP","INR","IQD","IRR","ISK","JEP","JMD","JOD","JPY","KES","KGS","KHR","KMF","KPW","KRW","KWD","KYD","KZT","LAK","LBP","LKR","LRD","LSL","LTL","LVL","LYD","MAD","MDL","MGA","MKD","MMK","MNT","MOP","MRO","MUR","MVR","MWK","MXN","MYR","MZN","NAD","NGN","NIO","NOK","NPR","NZD","OMR","PAB","PEN","PGK","PHP","PKR","PLN","PYG","QAR","RON","RSD","RUB","RWF","SAR","SBD","SCR","SDG","SEK","SGD","SHP","SLL","SOS","SPL","SRD","STD","SVC","SYP","SZL","THB","TJS","TMT","TND","TOP","TRY","TTD","TVD","TWD","TZS","UAH","UGX","USD","UYU","UZS","VEF","VND","VUV","WST","XAF","XCD","XDR","XOF","XPF","YER","ZAR","ZMW","ZWD","BTC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentTypeCurrencyPropEnum = append(paymentTypeCurrencyPropEnum, v)
	}
}

const (

	// PaymentCurrencyAED captures enum value "AED"
	PaymentCurrencyAED string = "AED"

	// PaymentCurrencyAFN captures enum value "AFN"
	PaymentCurrencyAFN string = "AFN"

	// PaymentCurrencyALL captures enum value "ALL"
	PaymentCurrencyALL string = "ALL"

	// PaymentCurrencyAMD captures enum value "AMD"
	PaymentCurrencyAMD string = "AMD"

	// PaymentCurrencyANG captures enum value "ANG"
	PaymentCurrencyANG string = "ANG"

	// PaymentCurrencyAOA captures enum value "AOA"
	PaymentCurrencyAOA string = "AOA"

	// PaymentCurrencyARS captures enum value "ARS"
	PaymentCurrencyARS string = "ARS"

	// PaymentCurrencyAUD captures enum value "AUD"
	PaymentCurrencyAUD string = "AUD"

	// PaymentCurrencyAWG captures enum value "AWG"
	PaymentCurrencyAWG string = "AWG"

	// PaymentCurrencyAZN captures enum value "AZN"
	PaymentCurrencyAZN string = "AZN"

	// PaymentCurrencyBAM captures enum value "BAM"
	PaymentCurrencyBAM string = "BAM"

	// PaymentCurrencyBBD captures enum value "BBD"
	PaymentCurrencyBBD string = "BBD"

	// PaymentCurrencyBDT captures enum value "BDT"
	PaymentCurrencyBDT string = "BDT"

	// PaymentCurrencyBGN captures enum value "BGN"
	PaymentCurrencyBGN string = "BGN"

	// PaymentCurrencyBHD captures enum value "BHD"
	PaymentCurrencyBHD string = "BHD"

	// PaymentCurrencyBIF captures enum value "BIF"
	PaymentCurrencyBIF string = "BIF"

	// PaymentCurrencyBMD captures enum value "BMD"
	PaymentCurrencyBMD string = "BMD"

	// PaymentCurrencyBND captures enum value "BND"
	PaymentCurrencyBND string = "BND"

	// PaymentCurrencyBOB captures enum value "BOB"
	PaymentCurrencyBOB string = "BOB"

	// PaymentCurrencyBRL captures enum value "BRL"
	PaymentCurrencyBRL string = "BRL"

	// PaymentCurrencyBSD captures enum value "BSD"
	PaymentCurrencyBSD string = "BSD"

	// PaymentCurrencyBTN captures enum value "BTN"
	PaymentCurrencyBTN string = "BTN"

	// PaymentCurrencyBWP captures enum value "BWP"
	PaymentCurrencyBWP string = "BWP"

	// PaymentCurrencyBYR captures enum value "BYR"
	PaymentCurrencyBYR string = "BYR"

	// PaymentCurrencyBZD captures enum value "BZD"
	PaymentCurrencyBZD string = "BZD"

	// PaymentCurrencyCAD captures enum value "CAD"
	PaymentCurrencyCAD string = "CAD"

	// PaymentCurrencyCDF captures enum value "CDF"
	PaymentCurrencyCDF string = "CDF"

	// PaymentCurrencyCHF captures enum value "CHF"
	PaymentCurrencyCHF string = "CHF"

	// PaymentCurrencyCLP captures enum value "CLP"
	PaymentCurrencyCLP string = "CLP"

	// PaymentCurrencyCNY captures enum value "CNY"
	PaymentCurrencyCNY string = "CNY"

	// PaymentCurrencyCOP captures enum value "COP"
	PaymentCurrencyCOP string = "COP"

	// PaymentCurrencyCRC captures enum value "CRC"
	PaymentCurrencyCRC string = "CRC"

	// PaymentCurrencyCUC captures enum value "CUC"
	PaymentCurrencyCUC string = "CUC"

	// PaymentCurrencyCUP captures enum value "CUP"
	PaymentCurrencyCUP string = "CUP"

	// PaymentCurrencyCVE captures enum value "CVE"
	PaymentCurrencyCVE string = "CVE"

	// PaymentCurrencyCZK captures enum value "CZK"
	PaymentCurrencyCZK string = "CZK"

	// PaymentCurrencyDJF captures enum value "DJF"
	PaymentCurrencyDJF string = "DJF"

	// PaymentCurrencyDKK captures enum value "DKK"
	PaymentCurrencyDKK string = "DKK"

	// PaymentCurrencyDOP captures enum value "DOP"
	PaymentCurrencyDOP string = "DOP"

	// PaymentCurrencyDZD captures enum value "DZD"
	PaymentCurrencyDZD string = "DZD"

	// PaymentCurrencyEGP captures enum value "EGP"
	PaymentCurrencyEGP string = "EGP"

	// PaymentCurrencyERN captures enum value "ERN"
	PaymentCurrencyERN string = "ERN"

	// PaymentCurrencyETB captures enum value "ETB"
	PaymentCurrencyETB string = "ETB"

	// PaymentCurrencyEUR captures enum value "EUR"
	PaymentCurrencyEUR string = "EUR"

	// PaymentCurrencyFJD captures enum value "FJD"
	PaymentCurrencyFJD string = "FJD"

	// PaymentCurrencyFKP captures enum value "FKP"
	PaymentCurrencyFKP string = "FKP"

	// PaymentCurrencyGBP captures enum value "GBP"
	PaymentCurrencyGBP string = "GBP"

	// PaymentCurrencyGEL captures enum value "GEL"
	PaymentCurrencyGEL string = "GEL"

	// PaymentCurrencyGGP captures enum value "GGP"
	PaymentCurrencyGGP string = "GGP"

	// PaymentCurrencyGHS captures enum value "GHS"
	PaymentCurrencyGHS string = "GHS"

	// PaymentCurrencyGIP captures enum value "GIP"
	PaymentCurrencyGIP string = "GIP"

	// PaymentCurrencyGMD captures enum value "GMD"
	PaymentCurrencyGMD string = "GMD"

	// PaymentCurrencyGNF captures enum value "GNF"
	PaymentCurrencyGNF string = "GNF"

	// PaymentCurrencyGTQ captures enum value "GTQ"
	PaymentCurrencyGTQ string = "GTQ"

	// PaymentCurrencyGYD captures enum value "GYD"
	PaymentCurrencyGYD string = "GYD"

	// PaymentCurrencyHKD captures enum value "HKD"
	PaymentCurrencyHKD string = "HKD"

	// PaymentCurrencyHNL captures enum value "HNL"
	PaymentCurrencyHNL string = "HNL"

	// PaymentCurrencyHRK captures enum value "HRK"
	PaymentCurrencyHRK string = "HRK"

	// PaymentCurrencyHTG captures enum value "HTG"
	PaymentCurrencyHTG string = "HTG"

	// PaymentCurrencyHUF captures enum value "HUF"
	PaymentCurrencyHUF string = "HUF"

	// PaymentCurrencyIDR captures enum value "IDR"
	PaymentCurrencyIDR string = "IDR"

	// PaymentCurrencyILS captures enum value "ILS"
	PaymentCurrencyILS string = "ILS"

	// PaymentCurrencyIMP captures enum value "IMP"
	PaymentCurrencyIMP string = "IMP"

	// PaymentCurrencyINR captures enum value "INR"
	PaymentCurrencyINR string = "INR"

	// PaymentCurrencyIQD captures enum value "IQD"
	PaymentCurrencyIQD string = "IQD"

	// PaymentCurrencyIRR captures enum value "IRR"
	PaymentCurrencyIRR string = "IRR"

	// PaymentCurrencyISK captures enum value "ISK"
	PaymentCurrencyISK string = "ISK"

	// PaymentCurrencyJEP captures enum value "JEP"
	PaymentCurrencyJEP string = "JEP"

	// PaymentCurrencyJMD captures enum value "JMD"
	PaymentCurrencyJMD string = "JMD"

	// PaymentCurrencyJOD captures enum value "JOD"
	PaymentCurrencyJOD string = "JOD"

	// PaymentCurrencyJPY captures enum value "JPY"
	PaymentCurrencyJPY string = "JPY"

	// PaymentCurrencyKES captures enum value "KES"
	PaymentCurrencyKES string = "KES"

	// PaymentCurrencyKGS captures enum value "KGS"
	PaymentCurrencyKGS string = "KGS"

	// PaymentCurrencyKHR captures enum value "KHR"
	PaymentCurrencyKHR string = "KHR"

	// PaymentCurrencyKMF captures enum value "KMF"
	PaymentCurrencyKMF string = "KMF"

	// PaymentCurrencyKPW captures enum value "KPW"
	PaymentCurrencyKPW string = "KPW"

	// PaymentCurrencyKRW captures enum value "KRW"
	PaymentCurrencyKRW string = "KRW"

	// PaymentCurrencyKWD captures enum value "KWD"
	PaymentCurrencyKWD string = "KWD"

	// PaymentCurrencyKYD captures enum value "KYD"
	PaymentCurrencyKYD string = "KYD"

	// PaymentCurrencyKZT captures enum value "KZT"
	PaymentCurrencyKZT string = "KZT"

	// PaymentCurrencyLAK captures enum value "LAK"
	PaymentCurrencyLAK string = "LAK"

	// PaymentCurrencyLBP captures enum value "LBP"
	PaymentCurrencyLBP string = "LBP"

	// PaymentCurrencyLKR captures enum value "LKR"
	PaymentCurrencyLKR string = "LKR"

	// PaymentCurrencyLRD captures enum value "LRD"
	PaymentCurrencyLRD string = "LRD"

	// PaymentCurrencyLSL captures enum value "LSL"
	PaymentCurrencyLSL string = "LSL"

	// PaymentCurrencyLTL captures enum value "LTL"
	PaymentCurrencyLTL string = "LTL"

	// PaymentCurrencyLVL captures enum value "LVL"
	PaymentCurrencyLVL string = "LVL"

	// PaymentCurrencyLYD captures enum value "LYD"
	PaymentCurrencyLYD string = "LYD"

	// PaymentCurrencyMAD captures enum value "MAD"
	PaymentCurrencyMAD string = "MAD"

	// PaymentCurrencyMDL captures enum value "MDL"
	PaymentCurrencyMDL string = "MDL"

	// PaymentCurrencyMGA captures enum value "MGA"
	PaymentCurrencyMGA string = "MGA"

	// PaymentCurrencyMKD captures enum value "MKD"
	PaymentCurrencyMKD string = "MKD"

	// PaymentCurrencyMMK captures enum value "MMK"
	PaymentCurrencyMMK string = "MMK"

	// PaymentCurrencyMNT captures enum value "MNT"
	PaymentCurrencyMNT string = "MNT"

	// PaymentCurrencyMOP captures enum value "MOP"
	PaymentCurrencyMOP string = "MOP"

	// PaymentCurrencyMRO captures enum value "MRO"
	PaymentCurrencyMRO string = "MRO"

	// PaymentCurrencyMUR captures enum value "MUR"
	PaymentCurrencyMUR string = "MUR"

	// PaymentCurrencyMVR captures enum value "MVR"
	PaymentCurrencyMVR string = "MVR"

	// PaymentCurrencyMWK captures enum value "MWK"
	PaymentCurrencyMWK string = "MWK"

	// PaymentCurrencyMXN captures enum value "MXN"
	PaymentCurrencyMXN string = "MXN"

	// PaymentCurrencyMYR captures enum value "MYR"
	PaymentCurrencyMYR string = "MYR"

	// PaymentCurrencyMZN captures enum value "MZN"
	PaymentCurrencyMZN string = "MZN"

	// PaymentCurrencyNAD captures enum value "NAD"
	PaymentCurrencyNAD string = "NAD"

	// PaymentCurrencyNGN captures enum value "NGN"
	PaymentCurrencyNGN string = "NGN"

	// PaymentCurrencyNIO captures enum value "NIO"
	PaymentCurrencyNIO string = "NIO"

	// PaymentCurrencyNOK captures enum value "NOK"
	PaymentCurrencyNOK string = "NOK"

	// PaymentCurrencyNPR captures enum value "NPR"
	PaymentCurrencyNPR string = "NPR"

	// PaymentCurrencyNZD captures enum value "NZD"
	PaymentCurrencyNZD string = "NZD"

	// PaymentCurrencyOMR captures enum value "OMR"
	PaymentCurrencyOMR string = "OMR"

	// PaymentCurrencyPAB captures enum value "PAB"
	PaymentCurrencyPAB string = "PAB"

	// PaymentCurrencyPEN captures enum value "PEN"
	PaymentCurrencyPEN string = "PEN"

	// PaymentCurrencyPGK captures enum value "PGK"
	PaymentCurrencyPGK string = "PGK"

	// PaymentCurrencyPHP captures enum value "PHP"
	PaymentCurrencyPHP string = "PHP"

	// PaymentCurrencyPKR captures enum value "PKR"
	PaymentCurrencyPKR string = "PKR"

	// PaymentCurrencyPLN captures enum value "PLN"
	PaymentCurrencyPLN string = "PLN"

	// PaymentCurrencyPYG captures enum value "PYG"
	PaymentCurrencyPYG string = "PYG"

	// PaymentCurrencyQAR captures enum value "QAR"
	PaymentCurrencyQAR string = "QAR"

	// PaymentCurrencyRON captures enum value "RON"
	PaymentCurrencyRON string = "RON"

	// PaymentCurrencyRSD captures enum value "RSD"
	PaymentCurrencyRSD string = "RSD"

	// PaymentCurrencyRUB captures enum value "RUB"
	PaymentCurrencyRUB string = "RUB"

	// PaymentCurrencyRWF captures enum value "RWF"
	PaymentCurrencyRWF string = "RWF"

	// PaymentCurrencySAR captures enum value "SAR"
	PaymentCurrencySAR string = "SAR"

	// PaymentCurrencySBD captures enum value "SBD"
	PaymentCurrencySBD string = "SBD"

	// PaymentCurrencySCR captures enum value "SCR"
	PaymentCurrencySCR string = "SCR"

	// PaymentCurrencySDG captures enum value "SDG"
	PaymentCurrencySDG string = "SDG"

	// PaymentCurrencySEK captures enum value "SEK"
	PaymentCurrencySEK string = "SEK"

	// PaymentCurrencySGD captures enum value "SGD"
	PaymentCurrencySGD string = "SGD"

	// PaymentCurrencySHP captures enum value "SHP"
	PaymentCurrencySHP string = "SHP"

	// PaymentCurrencySLL captures enum value "SLL"
	PaymentCurrencySLL string = "SLL"

	// PaymentCurrencySOS captures enum value "SOS"
	PaymentCurrencySOS string = "SOS"

	// PaymentCurrencySPL captures enum value "SPL"
	PaymentCurrencySPL string = "SPL"

	// PaymentCurrencySRD captures enum value "SRD"
	PaymentCurrencySRD string = "SRD"

	// PaymentCurrencySTD captures enum value "STD"
	PaymentCurrencySTD string = "STD"

	// PaymentCurrencySVC captures enum value "SVC"
	PaymentCurrencySVC string = "SVC"

	// PaymentCurrencySYP captures enum value "SYP"
	PaymentCurrencySYP string = "SYP"

	// PaymentCurrencySZL captures enum value "SZL"
	PaymentCurrencySZL string = "SZL"

	// PaymentCurrencyTHB captures enum value "THB"
	PaymentCurrencyTHB string = "THB"

	// PaymentCurrencyTJS captures enum value "TJS"
	PaymentCurrencyTJS string = "TJS"

	// PaymentCurrencyTMT captures enum value "TMT"
	PaymentCurrencyTMT string = "TMT"

	// PaymentCurrencyTND captures enum value "TND"
	PaymentCurrencyTND string = "TND"

	// PaymentCurrencyTOP captures enum value "TOP"
	PaymentCurrencyTOP string = "TOP"

	// PaymentCurrencyTRY captures enum value "TRY"
	PaymentCurrencyTRY string = "TRY"

	// PaymentCurrencyTTD captures enum value "TTD"
	PaymentCurrencyTTD string = "TTD"

	// PaymentCurrencyTVD captures enum value "TVD"
	PaymentCurrencyTVD string = "TVD"

	// PaymentCurrencyTWD captures enum value "TWD"
	PaymentCurrencyTWD string = "TWD"

	// PaymentCurrencyTZS captures enum value "TZS"
	PaymentCurrencyTZS string = "TZS"

	// PaymentCurrencyUAH captures enum value "UAH"
	PaymentCurrencyUAH string = "UAH"

	// PaymentCurrencyUGX captures enum value "UGX"
	PaymentCurrencyUGX string = "UGX"

	// PaymentCurrencyUSD captures enum value "USD"
	PaymentCurrencyUSD string = "USD"

	// PaymentCurrencyUYU captures enum value "UYU"
	PaymentCurrencyUYU string = "UYU"

	// PaymentCurrencyUZS captures enum value "UZS"
	PaymentCurrencyUZS string = "UZS"

	// PaymentCurrencyVEF captures enum value "VEF"
	PaymentCurrencyVEF string = "VEF"

	// PaymentCurrencyVND captures enum value "VND"
	PaymentCurrencyVND string = "VND"

	// PaymentCurrencyVUV captures enum value "VUV"
	PaymentCurrencyVUV string = "VUV"

	// PaymentCurrencyWST captures enum value "WST"
	PaymentCurrencyWST string = "WST"

	// PaymentCurrencyXAF captures enum value "XAF"
	PaymentCurrencyXAF string = "XAF"

	// PaymentCurrencyXCD captures enum value "XCD"
	PaymentCurrencyXCD string = "XCD"

	// PaymentCurrencyXDR captures enum value "XDR"
	PaymentCurrencyXDR string = "XDR"

	// PaymentCurrencyXOF captures enum value "XOF"
	PaymentCurrencyXOF string = "XOF"

	// PaymentCurrencyXPF captures enum value "XPF"
	PaymentCurrencyXPF string = "XPF"

	// PaymentCurrencyYER captures enum value "YER"
	PaymentCurrencyYER string = "YER"

	// PaymentCurrencyZAR captures enum value "ZAR"
	PaymentCurrencyZAR string = "ZAR"

	// PaymentCurrencyZMW captures enum value "ZMW"
	PaymentCurrencyZMW string = "ZMW"

	// PaymentCurrencyZWD captures enum value "ZWD"
	PaymentCurrencyZWD string = "ZWD"

	// PaymentCurrencyBTC captures enum value "BTC"
	PaymentCurrencyBTC string = "BTC"
)

// prop value enum
func (m *Payment) validateCurrencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentTypeCurrencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Payment) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	// value enum
	if err := m.validateCurrencyEnum("currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validatePaymentAttempts(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentAttempts) { // not required
		return nil
	}

	for i := 0; i < len(m.PaymentAttempts); i++ {
		if swag.IsZero(m.PaymentAttempts[i]) { // not required
			continue
		}

		if m.PaymentAttempts[i] != nil {
			if err := m.PaymentAttempts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paymentAttempts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("paymentAttempts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) validatePaymentID(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentID) { // not required
		return nil
	}

	if err := validate.FormatOf("paymentId", "body", "uuid", m.PaymentID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validatePaymentMethodID(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentMethodID) { // not required
		return nil
	}

	if err := validate.FormatOf("paymentMethodId", "body", "uuid", m.PaymentMethodID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateTransactions(formats strfmt.Registry) error {
	if swag.IsZero(m.Transactions) { // not required
		return nil
	}

	for i := 0; i < len(m.Transactions); i++ {
		if swag.IsZero(m.Transactions[i]) { // not required
			continue
		}

		if m.Transactions[i] != nil {
			if err := m.Transactions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transactions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("transactions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payment based on the context it is used
func (m *Payment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuditLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentAttempts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransactions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) contextValidateAuditLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuditLogs); i++ {

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) contextValidatePaymentAttempts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PaymentAttempts); i++ {

		if m.PaymentAttempts[i] != nil {
			if err := m.PaymentAttempts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paymentAttempts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("paymentAttempts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) contextValidateTransactions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Transactions); i++ {

		if m.Transactions[i] != nil {
			if err := m.Transactions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transactions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("transactions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
