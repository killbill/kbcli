// Code generated by go-swagger; DO NOT EDIT.

package kbmodel

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EventSubscription event subscription
//
// swagger:model EventSubscription
type EventSubscription struct {

	// audit logs
	AuditLogs []*AuditLog `json:"auditLogs"`

	// billing period
	// Enum: [DAILY WEEKLY BIWEEKLY THIRTY_DAYS THIRTY_ONE_DAYS SIXTY_DAYS NINETY_DAYS MONTHLY BIMESTRIAL QUARTERLY TRIANNUAL BIANNUAL ANNUAL SESQUIENNIAL BIENNIAL TRIENNIAL NO_BILLING_PERIOD]
	BillingPeriod string `json:"billingPeriod,omitempty"`

	// catalog effective date
	// Format: date-time
	CatalogEffectiveDate strfmt.DateTime `json:"catalogEffectiveDate,omitempty"`

	// effective date
	// Format: date-time
	EffectiveDate strfmt.DateTime `json:"effectiveDate,omitempty"`

	// event Id
	// Format: uuid
	EventID strfmt.UUID `json:"eventId,omitempty"`

	// event type
	// Enum: [START_ENTITLEMENT START_BILLING PAUSE_ENTITLEMENT PAUSE_BILLING RESUME_ENTITLEMENT RESUME_BILLING PHASE CHANGE STOP_ENTITLEMENT STOP_BILLING SERVICE_STATE_CHANGE]
	EventType string `json:"eventType,omitempty"`

	// is blocked billing
	IsBlockedBilling bool `json:"isBlockedBilling,omitempty"`

	// is blocked entitlement
	IsBlockedEntitlement bool `json:"isBlockedEntitlement,omitempty"`

	// phase
	Phase string `json:"phase,omitempty"`

	// plan
	Plan string `json:"plan,omitempty"`

	// price list
	PriceList string `json:"priceList,omitempty"`

	// product
	Product string `json:"product,omitempty"`

	// service name
	ServiceName string `json:"serviceName,omitempty"`

	// service state name
	ServiceStateName string `json:"serviceStateName,omitempty"`
}

// Validate validates this event subscription
func (m *EventSubscription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuditLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingPeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEventType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EventSubscription) validateAuditLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.AuditLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.AuditLogs); i++ {
		if swag.IsZero(m.AuditLogs[i]) { // not required
			continue
		}

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var eventSubscriptionTypeBillingPeriodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAILY","WEEKLY","BIWEEKLY","THIRTY_DAYS","THIRTY_ONE_DAYS","SIXTY_DAYS","NINETY_DAYS","MONTHLY","BIMESTRIAL","QUARTERLY","TRIANNUAL","BIANNUAL","ANNUAL","SESQUIENNIAL","BIENNIAL","TRIENNIAL","NO_BILLING_PERIOD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		eventSubscriptionTypeBillingPeriodPropEnum = append(eventSubscriptionTypeBillingPeriodPropEnum, v)
	}
}

const (

	// EventSubscriptionBillingPeriodDAILY captures enum value "DAILY"
	EventSubscriptionBillingPeriodDAILY string = "DAILY"

	// EventSubscriptionBillingPeriodWEEKLY captures enum value "WEEKLY"
	EventSubscriptionBillingPeriodWEEKLY string = "WEEKLY"

	// EventSubscriptionBillingPeriodBIWEEKLY captures enum value "BIWEEKLY"
	EventSubscriptionBillingPeriodBIWEEKLY string = "BIWEEKLY"

	// EventSubscriptionBillingPeriodTHIRTYDAYS captures enum value "THIRTY_DAYS"
	EventSubscriptionBillingPeriodTHIRTYDAYS string = "THIRTY_DAYS"

	// EventSubscriptionBillingPeriodTHIRTYONEDAYS captures enum value "THIRTY_ONE_DAYS"
	EventSubscriptionBillingPeriodTHIRTYONEDAYS string = "THIRTY_ONE_DAYS"

	// EventSubscriptionBillingPeriodSIXTYDAYS captures enum value "SIXTY_DAYS"
	EventSubscriptionBillingPeriodSIXTYDAYS string = "SIXTY_DAYS"

	// EventSubscriptionBillingPeriodNINETYDAYS captures enum value "NINETY_DAYS"
	EventSubscriptionBillingPeriodNINETYDAYS string = "NINETY_DAYS"

	// EventSubscriptionBillingPeriodMONTHLY captures enum value "MONTHLY"
	EventSubscriptionBillingPeriodMONTHLY string = "MONTHLY"

	// EventSubscriptionBillingPeriodBIMESTRIAL captures enum value "BIMESTRIAL"
	EventSubscriptionBillingPeriodBIMESTRIAL string = "BIMESTRIAL"

	// EventSubscriptionBillingPeriodQUARTERLY captures enum value "QUARTERLY"
	EventSubscriptionBillingPeriodQUARTERLY string = "QUARTERLY"

	// EventSubscriptionBillingPeriodTRIANNUAL captures enum value "TRIANNUAL"
	EventSubscriptionBillingPeriodTRIANNUAL string = "TRIANNUAL"

	// EventSubscriptionBillingPeriodBIANNUAL captures enum value "BIANNUAL"
	EventSubscriptionBillingPeriodBIANNUAL string = "BIANNUAL"

	// EventSubscriptionBillingPeriodANNUAL captures enum value "ANNUAL"
	EventSubscriptionBillingPeriodANNUAL string = "ANNUAL"

	// EventSubscriptionBillingPeriodSESQUIENNIAL captures enum value "SESQUIENNIAL"
	EventSubscriptionBillingPeriodSESQUIENNIAL string = "SESQUIENNIAL"

	// EventSubscriptionBillingPeriodBIENNIAL captures enum value "BIENNIAL"
	EventSubscriptionBillingPeriodBIENNIAL string = "BIENNIAL"

	// EventSubscriptionBillingPeriodTRIENNIAL captures enum value "TRIENNIAL"
	EventSubscriptionBillingPeriodTRIENNIAL string = "TRIENNIAL"

	// EventSubscriptionBillingPeriodNOBILLINGPERIOD captures enum value "NO_BILLING_PERIOD"
	EventSubscriptionBillingPeriodNOBILLINGPERIOD string = "NO_BILLING_PERIOD"
)

// prop value enum
func (m *EventSubscription) validateBillingPeriodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, eventSubscriptionTypeBillingPeriodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EventSubscription) validateBillingPeriod(formats strfmt.Registry) error {
	if swag.IsZero(m.BillingPeriod) { // not required
		return nil
	}

	// value enum
	if err := m.validateBillingPeriodEnum("billingPeriod", "body", m.BillingPeriod); err != nil {
		return err
	}

	return nil
}

func (m *EventSubscription) validateCatalogEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogEffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("catalogEffectiveDate", "body", "date-time", m.CatalogEffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EventSubscription) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("effectiveDate", "body", "date-time", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EventSubscription) validateEventID(formats strfmt.Registry) error {
	if swag.IsZero(m.EventID) { // not required
		return nil
	}

	if err := validate.FormatOf("eventId", "body", "uuid", m.EventID.String(), formats); err != nil {
		return err
	}

	return nil
}

var eventSubscriptionTypeEventTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["START_ENTITLEMENT","START_BILLING","PAUSE_ENTITLEMENT","PAUSE_BILLING","RESUME_ENTITLEMENT","RESUME_BILLING","PHASE","CHANGE","STOP_ENTITLEMENT","STOP_BILLING","SERVICE_STATE_CHANGE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		eventSubscriptionTypeEventTypePropEnum = append(eventSubscriptionTypeEventTypePropEnum, v)
	}
}

const (

	// EventSubscriptionEventTypeSTARTENTITLEMENT captures enum value "START_ENTITLEMENT"
	EventSubscriptionEventTypeSTARTENTITLEMENT string = "START_ENTITLEMENT"

	// EventSubscriptionEventTypeSTARTBILLING captures enum value "START_BILLING"
	EventSubscriptionEventTypeSTARTBILLING string = "START_BILLING"

	// EventSubscriptionEventTypePAUSEENTITLEMENT captures enum value "PAUSE_ENTITLEMENT"
	EventSubscriptionEventTypePAUSEENTITLEMENT string = "PAUSE_ENTITLEMENT"

	// EventSubscriptionEventTypePAUSEBILLING captures enum value "PAUSE_BILLING"
	EventSubscriptionEventTypePAUSEBILLING string = "PAUSE_BILLING"

	// EventSubscriptionEventTypeRESUMEENTITLEMENT captures enum value "RESUME_ENTITLEMENT"
	EventSubscriptionEventTypeRESUMEENTITLEMENT string = "RESUME_ENTITLEMENT"

	// EventSubscriptionEventTypeRESUMEBILLING captures enum value "RESUME_BILLING"
	EventSubscriptionEventTypeRESUMEBILLING string = "RESUME_BILLING"

	// EventSubscriptionEventTypePHASE captures enum value "PHASE"
	EventSubscriptionEventTypePHASE string = "PHASE"

	// EventSubscriptionEventTypeCHANGE captures enum value "CHANGE"
	EventSubscriptionEventTypeCHANGE string = "CHANGE"

	// EventSubscriptionEventTypeSTOPENTITLEMENT captures enum value "STOP_ENTITLEMENT"
	EventSubscriptionEventTypeSTOPENTITLEMENT string = "STOP_ENTITLEMENT"

	// EventSubscriptionEventTypeSTOPBILLING captures enum value "STOP_BILLING"
	EventSubscriptionEventTypeSTOPBILLING string = "STOP_BILLING"

	// EventSubscriptionEventTypeSERVICESTATECHANGE captures enum value "SERVICE_STATE_CHANGE"
	EventSubscriptionEventTypeSERVICESTATECHANGE string = "SERVICE_STATE_CHANGE"
)

// prop value enum
func (m *EventSubscription) validateEventTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, eventSubscriptionTypeEventTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EventSubscription) validateEventType(formats strfmt.Registry) error {
	if swag.IsZero(m.EventType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEventTypeEnum("eventType", "body", m.EventType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this event subscription based on the context it is used
func (m *EventSubscription) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuditLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EventSubscription) contextValidateAuditLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuditLogs); i++ {

		if m.AuditLogs[i] != nil {
			if err := m.AuditLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *EventSubscription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EventSubscription) UnmarshalBinary(b []byte) error {
	var res EventSubscription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
